这一道题，我做了大概半天，感悟良多，其中，最重要的是感叹自己基础不够，没有把这个问题考虑透彻。
参考了大佬们的思路，磕磕碰碰总算写出来了。
在编程中，最简单又最容易碰到的问题是数组越界，可是我却没有考虑清楚，还有马的位置会影响棋盘边界能否让卒落脚，这是一个简单的问题，却也是复杂的问题。
最开始我的写法是用一个30*30的数组暴力遍历所有棋盘上的点，但是我后来想到卒只能向下或向右移动，也就是说B点以后的点是影响不了B点的值得，所以只用考虑B点和A点围城的一个矩形的范围内的棋点。
同时，由于第一行的数据在计算完第二行的数据之后就没用了，第二行计算完第三行的数据就没用了，所以可以采用滚动数组的方式去遍历整个棋盘。
以下是我的代码：

#include <iostream>
#define ull unsigned long long
using namespace std;
ull f[23];
bool s[23][23];
int main() {
	int bx, by, mx, my;
	cin >> bx >> by >> mx >> my;
	bx+=2;
	by+=2;
	mx+=2;
	my+=2;
	int x[] = {0,1,1,-1,-1,2,2,-2,-2};
	int y[] = {0,2,-2,2,-2,1,-1,1,-1};
	for (int i = 0;i <= 8;i++) {
		s[mx + x[i]][my + y[i]] = 1;
	}
	f[2] = 1;
	for (int i = 2;i <= bx;i++) {
		for (int j = 2;j <= by;j++) {
			if (s[i][j]) {
				f[j] = 0;
			}
			else {
				f[j] +=f[j-1];
			}
		}
	}
	cout << f[by];
	return 0;
}
